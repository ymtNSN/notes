## 暴力递归
    递归有很多重复计算
    动态规划问题的第⼀个性质：重叠⼦问题
    算法的时间复杂度为 O(2^n)，
## 带备忘录的递归解法
⼀般使⽤⼀个数组充当这个「备忘录」，当然你也可以使⽤哈希表（字
典） 

算法的时间复杂度为 O(n)。

这种⽅法叫做「⾃顶向下」，动态规划叫做「⾃底向上」。

啥叫「⾃顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延
伸，都是从⼀个规模较⼤的原问题⽐如说 f(20) ，向下逐渐分解规模，直
到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「⾃顶向下」。

啥叫「⾃底向上」？反过来，我们直接从最底下，最简单，问题规模最⼩的
f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20) ，这就是动
态规划的思路，这也是为什么动态规划⼀般都脱离了递归，⽽是由循环迭代
完成计算。

动态规划问题最困难的就是写出状态转移⽅程 dp[i] = dp[i - 1] + dp[i - 2]

当前状态只和之前的两个状态有关，其实并不需要那么⻓的⼀个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就⾏了。

第⼀个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」
的⽅法来优化递归树，并且明确了这两种⽅法本质上是⼀样的，只是⾃顶向
下和⾃底向上的不同⽽已。
第⼆个凑零钱的问题，展⽰了如何流程化确定「状态转移⽅程」，只要通过
状态转移⽅程写出暴⼒递归解，剩下的也就是优化递归树，消除重叠⼦问题
⽽已。
如果你不太了解动态规划，还能看到这⾥，真得给你⿎掌，相信你已经掌握
了这个算法的设计技巧。
动态规划解题套路框架

计算机解决问题其实没有任何奇技淫巧，它唯⼀的解决办法就是穷举，穷举
所有可能性。算法设计⽆⾮就是先思考“如何穷举”，然后再追求“如何聪明
地穷举”。
列出动态转移⽅程，就是在解决“如何穷举”的问题。之所以说它难，⼀是因
为很多穷举需要递归实现，⼆是因为有的问题本⾝的解空间复杂，不那么容
易穷举完整。
备忘录、DP table 就是在追求“如何聪明地穷举”。⽤空间换时间的思路，是
降低时间复杂度的不⼆法门