## redis数据类型

### String 
底层数据结构：
int 长整型  embstr 短字符(<=39字节) raw 长字符(>39)
### Hash
底层数据结构：
ziplist:当field个数不超过hash-max-ziplist-entries(默认为512个)时,并且没有大   		  value(64个字节以上算大)
hashtable:ziplist的两个条件只要有一个不符合就会转换为hashtable
### List
底层数据结构：
ziplist（压缩列表）：当列表的元素个数小于list-max-ziplist-entries配置
（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时
（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使
用。
linkedlist（链表）：当列表类型无法满足ziplist的条件时，Redis会使用
linkedlist作为列表的内部实现。
### Set
底层数据结构：
intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-
intset-entries配置（默认512个）时，Redis会选用intset来作为集合的内部实
现，从而减少内存的使用。
hashtable（哈希表）：当集合类型无法满足intset的条件时，Redis会使
用hashtable作为集合的内部实现。
### ZSet
底层数据结构：
ziplist（压缩列表）：当有序集合的元素个数小于zset-max-ziplist-entries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配置（默认64字节）时，Redis会用ziplist来作为有序集合的内部实现，ziplist可以有效减少内存的使用。
skiplist（跳跃表）：当ziplist条件不满足时，有序集合会使用skiplist作为内部实现，因为此时ziplist的读写效率会下降。
时间复杂度O(log n)
## Redis异常
缓存穿透缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题
缓存降级
当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。
缓存更新除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：（1）定时去清理过期的缓存；
（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。

## Redis持久化
RDB持久化：是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。
注意：已过期的键不会被保存到新创建的RDB文件中
AOF持久化：以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。

AOF rewrite：rewrite会fork出一个子进程，创建一个临时文件，遍历数据库，将每个key、value对输出到临时文件。输出格式就是Redis的命令，但是为了减小文件大小，会将多个key、value对集合起来用一条命令表达。在rewrite期间的写操作会保存在内存的rewrite buffer中，rewrite成功后这些操作也会复制到临时文件中，在最后临时文件会代替AOF文件。
注意：如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响
当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加一个DEL命令，来显式地记录该键已被删除
## Redis 哨兵集群模式 至少3节点 
监控（Monitoring）: 哨兵（sentinel）通过流言协议（gossip protocols）会不断地检查你的Master和Slave是否运作正常；
提醒（Notification）：当被监控的某个Redis节点出现问题时, 哨兵（sentinel）可以通过 API 向管理员或者其他应用程序发送通知；
自动故障迁移（Automatic failover）：当一个Master不能正常工作时，哨兵通过投票协议（Agreement Protocols）会开始一次自动故障迁移操作，它会将其他一个Slave升级为新的Master，当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用现在的Master替换失效Master。Master和Slave服务器切换后，Master的redis.conf、Slave的redis.conf和sentinel.conf的配置文件的内容都会发生相应的改变，即，Master主服务器的redis.conf配置文件中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换。

## redis分布式锁
主要方法：setNX（只在键不存在的情况下，将key的值设置为value若key已经存在，则setnx命令不做任何动作）；expire设置过期时间。delete删除锁。启动守护线程监听主线程，如果时间片快消耗完了，就再续上一个时间片。

## Redisson分布式锁的底层原理 
默认情况下,加锁的时间是30秒,.如果加锁的业务没有执行完,就会进行一次续期,把锁重置成30秒.那这个时候可能又有同学问了,那业务的机器万一宕机了呢?宕机了定时任务跑不了,就续不了期,那自然30秒之后锁就解开了呗.
第一次加锁会判断锁存不存在，不存在就加锁加时间，如果锁存在，则会判断是否是可重入的锁id，如果是，则后面的一个int值++，如果不是原先自己加的锁，则会阻塞，并返回锁的剩余时间。

## 三种过期键删除策略

定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作
惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键
定期删除： 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多个过期键，以及要检查多少个数据库，则由算法决定


## 当前Redis3.0版本支持的淘汰策略有6种：
1. volatile-lru：从设置过期时间的数据集（server.db[i].expires）中挑选出最近最少使用的数据淘汰。没有设置过期时间的key不会被淘汰，这样就可以在增加内存空间的同时保证需要持久化的数据不会丢失。
2. volatile-ttl：除了淘汰机制采用LRU，策略基本上与volatile-lru相似，从设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰，ttl值越大越优先被淘汰。
3. volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。当内存达到限制无法写入非过期时间的数据集时，可以通过该淘汰策略在主键空间中随机移除某个key。
4. allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰，该策略要淘汰的key面向的是全体key集合，而非过期的key集合。
5. allkeys-random：从数据集(server.db[i].dict）中选择任意数据淘汰。
6. no-enviction：禁止驱逐数据，也就是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失，这也是系统默认的一种淘汰策略。

## Redis延迟队列
       延迟队列可以使用 zset（有序列表）实现，我们将消息序列化成一个字符串作为列表的value，这个消息的到期处理时间作为score，然后多个线程轮询zset 获取到期的任务进行执行，多线程保证了可靠性，因为多个线程，需要考虑并发执行的问题，一个任务不能被多次执行。

## Redis事务
Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的Redis会将一个事务中的所有命令序列化，然后按顺序执行。1.redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。2.如果在一个事务中的命令出现错误，那么所有的命令都不会执行；3.如果在一个事务中出现运行错误，那么正确的命令会被执行。注：redis的discard只是结束本次事务,正确命令造成的影响仍然存在.
1）MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。
2）EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。
3）通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。
4）WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。

## 管道
用于批处理，将一批命令打包发送到redis进行处理，redis会在处理所有命令前缓存处理结果，一并返回。
pipeline和“事务”是两个完全不同的概念，pipeline只是表达“交互”中操作的传递的方向性，pipeline也可以在事务中运行，也可以不在。
管道并不是redis服务端的技术，他是建立在用户端和网络上的。